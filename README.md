# Algorithm_Practice

## Dynamic Programming(basic)

    - RGB거리
        - 집마다 빨강, 초록, 파랑으로 칠할 때의 비용이 주어질 때, 이웃집의 색이 연속되지 않게 칠하는 비용의 최솟값을 구하라.
        => 집마다 칠하는 색 별 비용을 입력 받을때 입력받은 비용에 이 전에 입력받은 집에 다른색을 칠할 때의 비용 중 최소 비용을 더해준다.
        마지막 입력을 받을 때 까지 계속해서 더해준다.
        마지막 집을 빨강, 초록, 파랑으로 칠하는 세 경우중 최소비용인 경우를 찾는다.
                        
    - 정수 삼각형 
        - 맨 위층부터 시작해 아래층으로 한 층씩 내려오며 1층에 내려왔을 때 지나온 수의 합이 최대가 되는 경로의 합을 구하라.
        => 층마다 값을 입력 받으며 해당 값으로 내려 올 수 있는 경로의 값 중 더 큰 값을 더해준다.
        마지막 층의 수 중 더해진 값이 가장 큰 값을 찾는다.

    - 계단 오르기 
        - 각각의 점수가 있는 계단을 한 번에 한 계단 또는 두 계단씩 오를 수 있고, 세 개의 계단을 연속해서 오르지 못하는 계단에서 도착점까지 올랐을 때 얻을 수 있는 점수의 최댓값을 구하라.
        => 계단을 올랐을 때, 그 계단이 2번 연속 밟은 계단인지, 처음 밟은 계단인지, 밟지 않는 계단인지 세 가지로 구분해 값을 저장한다.
        마지막 계단은 무조건 밟는 경우로 가정한다.
        나온 값중 최대를 구한다.

    - 1로 만들기
        - 정수 N이 주어지고 X/3, X/2, X-1 이 세 연산을 적절히 사용해 1을 만들때, 연산 횟수의 최솟값을 구하라.
        => BFS를 이용해 모든 경우의 수를 한 턴에 비교. 1이 한 번이라도 나오면 바로 탈출, count 출력.

    - ACM Craft
        - 각 건물마다 짓는 순서와 지을 때 걸리는 시간이 주어질 때 건설하려는 건물을 짓기 까지 걸리는 최소 시간을 구하라.
        => 메모리 초과...

    - 쉬운 계단 수
        - 모든 인접한 모든 자리수의 차이가 1이 나는 수를 계단 수라 할 때, 길이가 N인 계단 수의 총 개수를 1,000,000,000으로 나눈 나머지를 구하라
        => 1의 자리의 수의 개수를 구한다.
        num[i][j] = num[i-1][j-1] + num[i-1][i+1]
 
    - 동전1
        - n가지 종류의 동전을 이용해 그 가치의 합이 k가 되게하는 경우의 수를 구하라.
        => 참고.
        => d[비용] += d[비용 - coin]
        
    - 포도주 시식
        - 테이블 위의 다양한 포도주를 최대로 많이 마실 때의 마시는 포도주의 양을 구하라. 이 때 연속해서 놓여있는 3잔을 모두 마실 수 없다.
        => 포도주를 마실 때, 현재 마시는 포도주를 1. 처음 마시는 포도주 혹은 전의 포도주를 뛰어 넘고 마시는 포도주, 2. 두 번 연속으로 마시고 있는 포도주, 3. 마시지 않을 포도주 이렇게 세 경우로 구분하여 지금까지 마신 포도주의 양을 저장한다. 3번의 경우는 그전 포도주에서 나온 세가지 경우 중에서 가장 큰 값을 저장한다.
         마지막 포도주까지 나온 경우의 수 3가지 중 가장 큰 값을 구한다.

    - 내리막 길
        - 지점의 높이가 나와있는 지도의 제일 왼쪽 위 칸에서 제일 오른쪽 아래 칸으로 항상 높이가 더 낮은 지점으로만 이동하여 가는 경로의 수를 구하라. 이동은 이웃한 상하좌우로만 가능하다.
        => 역으로 도착지점에서부터 현재 지점보다 높은 지점으로 이동하며 계산한다. 재귀함수를 돌며 출발지점까지 경로의 개수가 정해진 지점의 경로의 수를 저장해 재귀의 횟수를 줄인다.

    - LCS
        - 두 문자열의 LCS(Longest Common Subsequence , 최장 공통 부분 수열)의 길이를 구하라.
        => 이중포문을 통해 두 문자열의 첫번째 문자부터 모든 문자를 비교하며 길이를 저장하고, 더해준다.
         length[i][j] = length[i-1][j-1]+1;
         length[i][j] = (length[i][j-1] > length[i-1][j]) ? length[i][j-1] : length[i-1][j];
        
    - 파일 합치기
        - 장마다 나누어 다른 파일에 저장한 소설을 각 장이 들어있는 파일을 합처 최종적으로 소설의 완성본이 들어있는 한 개의 파일을 만드는 최소 비용을 구하라. 두 파일을 합칠 때 드는 비용은 두 파일의 크기의 합이다.
        => cost[i][j]를 i 장부터 j장까지 합칠 때의 비용이라고 할 때, cost[i][j] = cost[i][k] + cost[k+1][j] + total임을 이용한다. k를 i에서 j까지 늘려가며 계산하여 가장 작은 cost[i][j]의 값을 찾는다. 각 연산은 재귀함수를 통해 계산하며, 재귀의 횟수를 줄이기 위해 한 번 구한 cost[i][j]는 저장한다.
    
    - 연속 합
        - n개의 정수로 이루어진 임의의 수열에서 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하라. 수는 한 개 이상 선택해야 한다.
        => 참고.
        => 맨 앞의 수를 buffer와 answer에 저장한다. 두번째 수부터 하나씩 이동하며 '버퍼의 값과 현재 값의 합'과 '현재 값'을 비교해 더 큰 값을 버퍼에 넣는다. buffer의 값이 answer의 값보다 클 때, answer값을 buffer값으로 바꾼다.
         마지막 수 까지 계산한 후의 answer이 구할 수 있는 합 중 가장 큰 합이다.
    
    - 파도반 수열
        - 정삼각형이 나선 모양으로 놓여져 있다. 첫 삼각형의 변의 길이는 1이다. 그 다음에는 나선에서 가장 긴 변의 길이가 k일 때, 그 변을 한 변으로 하는 각 변의 길이가 k인 정삼각형을 추가한다. P(N)은 나선에 있는 N번째 정삼각형의 변의 길이이다. N이 주어졌을 때, P(N)을 구하라.
        => P(1)부터 P(12)까지 1,1,1,2,2,3,4,5,7,9,12,16이다. P(5)이후로, P(6)부터 P(N) = P(N-1) + P(n-5)임을 알 수 있다.
         재귀함수와 메모이제이션을 이용해 풀었다.
    
    - LCS2
        - 두 문자열의 LCS와 LCS의 길이를 구하라.
        => 위의 LCS문제와 같이 길이를 구하고, 길이를 저장한 배열 length의 마지막 부분부터 위 혹은 왼쪽으로 거슬러 올라가면서 위,왼쪽 모두 length보다 작으면 대각선으로 이동하며 빈 문자열에 해당 문자를 추가한다.
