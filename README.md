# Algorithm_Practice

## Dynamic Programming
    - RGB거리
        - 집마다 빨강, 초록, 파랑으로 칠할 때의 비용이 주어질 때, 이웃집의 색이 연속되지 않게 칠하는 비용의 최솟값을 구하라.
        => 집마다 칠하는 색 별 비용을 입력 받을때 입력받은 비용에 이 전에 입력받은 집에 다른색을 칠할 때의 비용 중 최소 비용을 더해준다.
        마지막 입력을 받을 때 까지 계속해서 더해준다.
        마지막 집을 빨강, 초록, 파랑으로 칠하는 세 경우중 최소비용인 경우를 찾는다.
                        
    - 정수 삼각형 
        - 맨 위층부터 시작해 아래층으로 한 층씩 내려오며 1층에 내려왔을 때 지나온 수의 합이 최대가 되는 경로의 합을 구하라.
        => 층마다 값을 입력 받으며 해당 값으로 내려 올 수 있는 경로의 값 중 더 큰 값을 더해준다.
        마지막 층의 수 중 더해진 값이 가장 큰 값을 찾는다.

    - 계단 오르기 
        - 각각의 점수가 있는 계단을 한 번에 한 계단 또는 두 계단씩 오를 수 있고, 세 개의 계단을 연속해서 오르지 못하는 계단에서 도착점까지 올랐을 때 얻을 수 있는 점수의 최댓값을 구하라.
        => 계단을 올랐을 때, 그 계단이 2번 연속 밟은 계단인지, 처음 밟은 계단인지, 밟지 않는 계단인지 세 가지로 구분해 값을 저장한다.
        마지막 계단은 무조건 밟는 경우로 가정한다.
        나온 값중 최대를 구한다.

    - 1로 만들기
        - 정수 N이 주어지고 X/3, X/2, X-1 이 세 연산을 적절히 사용해 1을 만들때, 연산 횟수의 최솟값을 구하라.
        => BFS를 이용해 모든 경우의 수를 한 턴에 비교. 1이 한 번이라도 나오면 바로 탈출, count 출력.

    - ACM Craft
        - 각 건물마다 짓는 순서와 지을 때 걸리는 시간이 주어질 때 건설하려는 건물을 짓기 까지 걸리는 최소 시간을 구하라.
        => 메모리 초과...

    - 쉬운 계단 수
        - 모든 인접한 모든 자리수의 차이가 1이 나는 수를 계단 수라 할 때, 길이가 N인 계단 수의 총 개수를 1,000,000,000으로 나눈 나머지를 구하라
        => 1의 자리의 수의 개수를 구한다.
        num[i][j] = num[i-1][j-1] + num[i-1][i+1]
 
    - 동전1
        - n가지 종류의 동전을 이용해 그 가치의 합이 k가 되게하는 경우의 수를 구하라
        => 참고.
        => d[비용] += d[비용 - coin]
