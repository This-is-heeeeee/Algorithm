# Algorithm_Practice

## Dynamic Programming

    - RGB거리
        - 집마다 빨강, 초록, 파랑으로 칠할 때의 비용이 주어질 때, 이웃집의 색이 연속되지 않게 칠하는 비용의 최솟값을 구하라.
        => 집마다 칠하는 색 별 비용을 입력 받을때 입력받은 비용에 이 전에 입력받은 집에 다른색을 칠할 때의 비용 중 최소 비용을 더해준다.
        마지막 입력을 받을 때 까지 계속해서 더해준다.
        마지막 집을 빨강, 초록, 파랑으로 칠하는 세 경우중 최소비용인 경우를 찾는다.
                        
    - 정수 삼각형 
        - 맨 위층부터 시작해 아래층으로 한 층씩 내려오며 1층에 내려왔을 때 지나온 수의 합이 최대가 되는 경로의 합을 구하라.
        => 층마다 값을 입력 받으며 해당 값으로 내려 올 수 있는 경로의 값 중 더 큰 값을 더해준다.
        마지막 층의 수 중 더해진 값이 가장 큰 값을 찾는다.

    - 계단 오르기 
        - 각각의 점수가 있는 계단을 한 번에 한 계단 또는 두 계단씩 오를 수 있고, 세 개의 계단을 연속해서 오르지 못하는 계단에서 도착점까지 올랐을 때 얻을 수 있는 점수의 최댓값을 구하라.
        => 계단을 올랐을 때, 그 계단이 2번 연속 밟은 계단인지, 처음 밟은 계단인지, 밟지 않는 계단인지 세 가지로 구분해 값을 저장한다.
        마지막 계단은 무조건 밟는 경우로 가정한다.
        나온 값중 최대를 구한다.

    - 1로 만들기
        - 정수 N이 주어지고 X/3, X/2, X-1 이 세 연산을 적절히 사용해 1을 만들때, 연산 횟수의 최솟값을 구하라.
        => BFS를 이용해 모든 경우의 수를 한 턴에 비교. 1이 한 번이라도 나오면 바로 탈출, count 출력.

    - ACM Craft
        - 각 건물마다 짓는 순서와 지을 때 걸리는 시간이 주어질 때 건설하려는 건물을 짓기 까지 걸리는 최소 시간을 구하라.
        => 메모리 초과...

    - 쉬운 계단 수
        - 모든 인접한 모든 자리수의 차이가 1이 나는 수를 계단 수라 할 때, 길이가 N인 계단 수의 총 개수를 1,000,000,000으로 나눈 나머지를 구하라
        => 1의 자리의 수의 개수를 구한다.
        num[i][j] = num[i-1][j-1] + num[i-1][i+1]
 
    - 동전1
        - n가지 종류의 동전을 이용해 그 가치의 합이 k가 되게하는 경우의 수를 구하라.
        => 참고.
        => d[비용] += d[비용 - coin]
        
    - 포도주 시식
        - 테이블 위의 다양한 포도주를 최대로 많이 마실 때의 마시는 포도주의 양을 구하라. 이 때 연속해서 놓여있는 3잔을 모두 마실 수 없다.
        => 포도주를 마실 때, 현재 마시는 포도주를 1. 처음 마시는 포도주 혹은 전의 포도주를 뛰어 넘고 마시는 포도주, 2. 두 번 연속으로 마시고 있는 포도주, 3. 마시지 않을 포도주 이렇게 세 경우로 구분하여 지금까지 마신 포도주의 양을 저장한다. 3번의 경우는 그전 포도주에서 나온 세가지 경우 중에서 가장 큰 값을 저장한다.
        마지막 포도주까지 나온 경우의 수 3가지 중 가장 큰 값을 구한다.

    - 내리막 길
        - 지점의 높이가 나와있는 지도의 제일 왼쪽 위 칸에서 제일 오른쪽 아래 칸으로 항상 높이가 더 낮은 지점으로만 이동하여 가는 경로의 수를 구하라. 이동은 이웃한 상하좌우로만 가능하다.
        => 역으로 도착지점에서부터 현재 지점보다 높은 지점으로 이동하며 계산한다. 재귀함수를 돌며 출발지점까지 경로의 개수가 정해진 지점의 경로의 수를 저장해 재귀의 횟수를 줄인다.

    - LCS
        - 두 문자열의 LCS(Longest Common Subsequence , 최장 공통 부분 수열)의 길이를 구하라.
        => 이중포문을 통해 두 문자열의 첫번째 문자부터 모든 문자를 비교하며 길이를 저장하고, 더해준다.
        length[i][j] = length[i-1][j-1]+1;
        length[i][j] = (length[i][j-1] > length[i-1][j]) ? length[i][j-1] : length[i-1][j];
